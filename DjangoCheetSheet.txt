Git exclude:
/.idea/
/.*
/db.sqlite3


New project:
	1. Packeges:
		- psycopg2-binary (for PostgreSQL)
	2. Docker:
		- Create "Dockerfile"
		- Create "docker-compose.yml"
		- docker-compose up -d --build
		- http://127.0.0.1:8000/
		- Check that django main page is loading
	3. First migration: (https://docs.djangoproject.com/en/3.2/topics/auth/customizing/#substituting-a-custom-user-model)
		- Edit "DATABASES" in "settings.py" for desired DB
		- docker-compose exec web python manage.py startapp accounts
		- Create "class CustomUser(AbstractUser)" in "accounts/models.py"
			id = models.UUIDField(  # configure id/pk to be UUID
									primary_key=True,  # set as primary key
									defalt=uuid.uuid4,  # set uuid4 for encription
									editable=False  # make unique
									)
		- "settings.py":
			* Add "accounts" to "INSTALLED_APPS"
			* Add "AUTH_USER_MODEL = 'accounts.CustomUser'"
		- Docker commands:
			* docker-compose exec web python manage.py makemigrations accounts
			* docker-compose exec web python manage.py migrate
	4. Create superuser
		- "accounts/admin.py":
			* Create "CustomUserManager(UserManager)" if needed
			* "User = get_user_model()"
			* "CustomUserAdmin(UserAdmin)"
			* "admin.site.register(User, CustomUserAdmin)"
		- docker-compose exec web python manage.py createsuperuser
		- Go to http://127.0.0.1:8000/admin and test login
	5. Unit Tests:
		- "class UserTest":
			* "def test_create_user(self)"
			* "def test_create_superuser(self)"
		- docker-compose exec web python manage.py test
	6. User CRUD:
		- Docker commands:
			* docker-compose exec web pipenv install django-allauth
			* docker-compose down
			* docker-compose up -d --build
		- settings.py:
			* Add "allauth" and "allauth.accounts" and "django.contrib.sites" to "INSTALLED_APPS"
			* Add "SITE_ID = 1"
			* AUTHENTICATION_BACKENDS = [
											# Needed to login by username in Django admin, regardless of `allauth`
											'django.contrib.auth.backends.ModelBackend',

											# `allauth` specific authentication methods, such as login by e-mail
											'allauth.account.auth_backends.AuthenticationBackend',
										]  # Authentication backend
			* SOCIALACCOUNT_PROVIDERS = {  # Only if needed
										    'google': {
										        # For each OAuth based provider, either add a ``SocialApp``
										        # (``socialaccount`` app) containing the required client
										        # credentials, or list them here:
										        'APP': {
										            'client_id': '123',
										            'secret': '456',
										            'key': ''
										        }
										    }
										}  # Provider specific settings
			* EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'  # Temporary email backend. Should be SMTP backend in deployed version
			* LOGIN_REDIRECT_URL = 'home'  # Redirects to 'home' url after login
			* ACCOUNT_LOGOUT_REDIRECT = 'home'  # Redirects to 'home' url after logout
			* ACCOUNT_SESSION_REMEMBER = None  # None: asks the user if to remember session, True: to remember session, False: to not remember session
			* ACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False  # True: asks the user to enter the password 2 times at sign up, False: asks the user to enter the password 1 time at sign up
		- "docker-compose exec web python manage.py migrate"
		- Add "path('accounts/', include('allauth.urls'))," in "urlpatterns" in the main "accounts/urls.py"
		- Add templates to "templates/account/" directory
			* 'login.html'
			* 'logout.html'
			* 'signup.html'
		- Correct urls:
			* 'account_login'
			* 'account_logout'
			* 'account_signup'
		- Login using Email:
			* "setting.py"
				* ACCOUNT_USERNAME_REQUIRED = False
				* ACCOUNT_AUTHENTICATION_METHOD = 'email'
				* ACCOUNT_EMAIL_REQUIRED = True
				* ACCOUNT_UNIQUE_EMAIL = True
			* 'username' will be automatically populated by removing the text after '@' in the email. If username conflict, allauth automatically ads a random integer at the end of the username
		- Tests:
			* "class UserTest":
				* "def test_signup(self)"
			* docker-compose exec web python manage.py test
	7. Environment variables:
		- Install Environs:
			* docker-compose exec web pipenv install 'environs[django]'
			* decker-compose down
			* docker-compose up -d --build
		- "settings.py"
			* from environs import #!/usr/bin/env python
			* env = Env()
			* env.read_env()
			* SECRET_KEY = env("DJANGO_SECRETE_KEY")
			* DEBUG = env.bool("DJANGO_DEBUG", default=False)
			* ALLOWED_HOSTS = ['localhost', '127.0.0.1']
			* DATABASES = {
							"default": env.dj_db_url("DATABASE_URL", default="postgres://postgres@db/postgres")
							}
		- In "evironment:" under "web" in 'docker-compose.yml' (if there is '$' sign, then you need cahnge to '$$'):
			* - "DJANGO_SECRETE_KEY=gr3e87i3y4hith3uoierws9834"
			* - "DJANGO_DEBUG=createsuperuser"
	8. Email:
		- Crate files (https://github.com/pennersr/django-allauth/tree/master/allauth/templates/account/email):
			* templates/account/email/email_confirmation_signup_subject.txt
			* templates/account/email/email_confirmation_signup_message.txt
			* templates/account/email/emial_confirmation_subject.txt
			* templates/account/email/emial_confirmation_message.txt
		- Change "Site Name" and "Domain Name":
			*  Log in to admin pannel
			*  Select "example.com" and Edit "Site Name" and "Domain Name"
		- Add "DEFAULT_FROM_EMAIL = admin@mail.com" to "settings.py"
		- Configure Email, "settings.py":
			* "EMAIL_BACKEND = django.core.mail.backends.smtp.EmailBackend"
			* "EMAIL_HOST"
			* "EMAIL_HOST_USER"
			* "EMAIL_HOST_PASSWORD"
			* "EMAIL_PORT"
			* "EMAIL_USE_TLS"
	9. Create an App:
		- docker-compose exec web python manage.py createapp app_name
		- Add "app_name" to "INSTALLED_APPS" in "settings.py"
		- Edit "app_name/model.py" in "app_name":
			* "class CustomModel(models.Model)"  # Define Model structure
				id = models.UUIDField(  # configure id/pk to be UUID
										primary_key=True,  # set as primary key
										defalt=uuid.uuid4,  # set uuid4 for encription
										editable=False  # make unique
										)
			* "def __str__(self)"  # Return string representation of the Model
			* "def get_absolute_url(self)"  # Sets the canonical URL for the Model
				return reverse(url, args=[str(self.id)])
		- docker-compose exec web python manage.py makemigrations app_name
		- docker-compose exec web python manage.py migrate
		- Edit "app_name/admin.py" in "app_name":
			* "calss CustomAdminModel(admin.ModelAdmin)"  # Custom Admin Model representation
				"list_display = (field1, field2, field3,)"  # fields to display in Admin Panel
			* "admin.site.register(CustomModel, CustomAdminModel)"
		- Configure URLs
			* To refere to a specific id, use "<uuid:pk>"
		- Configure Views
		- Create Templates for a non-REST site
		- Unit tests CRUD
	10. Create Reviews:
		- Add to "app_name/models.py":
			* "class Reviews(models.Model)"
			* post = models.ForeignKey(  # Onew to many relationship
										Post,  # Relationship model
										on_delete=models.CASCADE,  # Delete review when deleting post
										related_name='reviews'  # Name for Post instance to indicate a review
										)
		- docker-compose exec web python manage.py makemigrations app_name
		- docker-compose exec web python manage.py migrate
		- Edit "app_name/admin.py":
			* class ReviewInline(admin.TabularInline):
				model = Review
			* In "CustomAdminModel" add:
				inlines = [ReviewInline]
		- Unit test CRUD
	11. Permissions:
		- Using Mixin:
			* Add "LoginRequiredMixin" to the desired class based views as 1st inheritence
			* In the view, add "login_url = 'account_login'"
		- Custom permissions to "custom_model":
			* Add to Meta class in the custom_model class:
				permissions = [('permission_name', 'Permission description'),]
			* Add "permission_name" to the desired users
			* Add "PermissionRequiredMixin" to the desired view 2nd inheritence and add:
				permission_reqired = 'custom_model.permision_name'
		- Use "UserPassesTestMixin" and "Groups" to make more restricting permissions
		- Unit tests
	12. Performance
		- django-debug-tollbar
			* docker-compose exec web pipenv install django-debug-toolbar
			* decker-compose down
			* Add 'debug-toolbar' to "INSTALLED_APPS" in "settings.py"
			* Add 'debug_toolbar.middleware.DebugToolbarMiddleware' to "MIDDLEWARE" in "settings.py"
			* Add to 'settings.py'
				import socket
				hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())
				INTERNAL_IPS = [ip[:-1] + "1" for ip in ips]
			* docker-compose up -d --build
			* Add to the main "urls.py"
				if settings.DEBUG:
					import debug_toolbar
					urlpatterns = [
					path('__debug__/', include(debug_toolbar.urls)),
					] + urlpatterns
		- select_related()
			* https://docs.djangoproject.com/en/3.2/ref/models/querysets/#select-related
			* Debug tool for one-to-one and one-to-many Relationship
			* The JOIN is done in SQL
		- prefetch_related()
			* https://docs.djangoproject.com/en/3.2/ref/models/querysets/#prefetch-related
			* Debug tool for many-to-one and many-to-many Relationship
			* The JOIN is done in Python
		- Cashing
			* Most common packeges are "Memcache" and "Redis"
			* https://docs.djangoproject.com/en/3.2/topics/cache/
			* https://redis.io/
			* 4 types of caching:
				* https://docs.djangoproject.com/en/3.2/topics/cache/#the-per-site-cache
				* https://docs.djangoproject.com/en/3.2/topics/cache/#the-per-view-cache
				* https://docs.djangoproject.com/en/3.2/topics/cache/#template-fragment-caching
				* https://docs.djangoproject.com/en/3.2/topics/cache/#the-low-level-cache-api
			* For per-site caching, add to "settings.py":
				* MIDDLEWARE = [
				'django.middleware.cache.UpdateCacheMiddleware',
				...,
				'django.middleware.cache.FetchCacheMiddleware'
				]
				* CACHE_MIDDLEWARE_ALIAS = 'default'
				* CACHE_MIDDLEWARE_SECONDS = 604800  # One week
				* CACHE_MIDDLEWARE_KEY_PREFIX = ''
		- Indexing
			* Rule of thumb, add indexing for fields used in 10-25% of all queries.
			* Add in the "Meta" class inside the desired Model class:
				indexes = [
				models.Index(fields=['field_name'], name='index_name')
				]
			* Create new migrations and migrate
		- django-extensions
			* https://django-extensions.readthedocs.io/en/latest/
			* Popular extension is "shell_plus" that loads all models to the shell_plus
		- Front-end Assets:
			* django-compression to compress CSS and JS files (https://github.com/django-compressor/django-compressor)
			* Use CDN (Content Delivery Network) for email_confirmation_signup_message
			* easy-thumbnails to save several image sizes (https://github.com/SmileyChris/easy-thumbnails)
			* Images optimization e-book: https://web.dev/fast/#optimize-your-images
			* Automated test for front-end speed: https://developers.google.com/speed/pagespeed/insights/
	13. Security
		- 



Static Assets:
	1. Edit "settings.py":
		- STATIC_URL = '/static/'  # Sets the URL that we can use to reference static files
		- STATICFILES_DIRS = [str(BASE_DIR.joinpath('static')),]  # Define the location of static file in local development
		- STATIC_ROOT = str(BASE_DIR.joinpath('staticfiles'))  # Defines the location of static files in production
		- # STATICFILES_STORAGE # File storage engine to use when collecting static files with the collectstatic management command. Default: django.contrib.staticfiles.storage.StaticFilesStorage
		- STATICFILE_FINDER = [
									# Find files stored in the STATICFILES_DIRS setting
									'django.contrib.staticfiles.finders.FileSystemFinder',

									# Find files stored in a static subdirectory of each app
									'django.contrib.staticfiles.finders.AppDirectoriesFinder',
								]  # List of finder backends that know how to find static files in various locations
	2. Create directories:
		- static
		- static/css
		- static/js
		- static/images
	3. Load static files in a HTML template using "{% load static %}"
	4. To collect static files for production, run "docker-compose exec web python manage.py collectstatic"



File/Image Upload:
	1. Docker commands
		- docker-compose exec web pipenv install pillow
		- docker-compose down
		- docker-compose up -d --build
	2. Add to "settings.py". Add after "STATICFILES_FINDER":
		- "MEDIA_ROOT = '/media/'"  # Absolute file system path to the directory for user-uploaded FileSystemFinder
		- "MEDIA_URL = str(BASE_DIR/joinpath('media'))"  # URL for templates
	3. create directory 'media'
	4. Add to main 'urls.py':
		- from django.conf import settings
		- from django.conf.urls.static import static
		- urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
	5. Add "models.ImageField(upload_to='folder_name/')"  # fill be loaded from MEDIA_ROOT/folder_name
		- To upload regular file, change ImageField to File field1
		- Add "blank=True" to ImageField if databese is already populated
	6. Docker commands:
		- docker-compose exec web python manage.py makemigrations app_name
		- docker-compose exec web python manage.py migrate



Search:
	1. Add new path 'search/' to "urlpatterns" in the main "urls.py"
	2. Create a view. This view may extend from "ListView"
		- queryset = Post.objects.filter()  # Example of simple filtering
			* Simple querysets:
				* filter()
				* all()
				* get()
				* exclude()
			* https://docs.djangoproject.com/en/3.2/topics/db/queries/#retrieving-objects
			* https://docs.djangoproject.com/en/3.2/topics/db/managers/#django.db.models.Manager
			* https://docs.djangoproject.com/en/3.2/ref/models/querysets/#contains
		- def get_queryset(self):  # For more complex filtering
			return Post.objects.filter(
										query = self.request.GET.get('q')
										Q(filter_logic_1=q) | Q(filter_logic_2=q)
										)
	4. For a non-REST website, create a template



crispy_forms :
	1. docker-compose exec web pipenv install django-crispy-forms
	2. Add 'crispy_forms', to "INSTALLED_APPS" in "setting.py"
	4. Add "CRISPY_TEMPLATE_PACK = 'uni_form'" to "setting.py"
		- The following template packs are avaliable:
			* bootstrap
			* bootstrap3
			* bootstrap4
			* uni_form
			* foundation
			* tailwind
	5. Add "{% load crispy_forms_tags %}" at the top of a HTML template
		- Change "{{ form.as_p }}" to "{{ form|crispy }}"



First Deployment:
	1. Install gunicorn
	2. Create Procfile file in root
		web: gunicorn PROJECT_NAME:wsgi --log-file -
	3. heroku login
	4. heroku crate --website_name
	5. heroku git:remote -a --website_name
	6. herokuaddons:create heroku-postgresql:hobby-dev
	7. heroku configure:set SECRET_KEY='--secrete_key'
	8. git push heroku master
	9. heroku ps:scale web=1
	10. heroku run python manage.py migrate
	10. heroku run python manage.py createsuperuser



Deployment:
	1. heroku login
	2. git push heroku master
	3. heroku ps:scale web=1
